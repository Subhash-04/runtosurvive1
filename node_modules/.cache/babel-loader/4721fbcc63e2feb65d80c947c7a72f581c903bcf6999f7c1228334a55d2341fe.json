{"ast":null,"code":"import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };","map":{"version":3,"names":["Vector3","Vector3$1","Quaternion","Quaternion$1","ActiveEvents","ColliderDesc","EventQueue","RigidBodyDesc","CoefficientCombineRule","Collider","RapierCollider","RigidBody","RapierRigidBody","useFrame","useThree","React","useRef","useEffect","memo","useMemo","useContext","useState","createContext","useCallback","forwardRef","Fragment","Euler","Object3D","Matrix4","BufferAttribute","MathUtils","DynamicDrawUsage","suspend","mergeVertices","_toPrimitive","t","r","e","Symbol","toPrimitive","i","call","TypeError","String","Number","_toPropertyKey","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","_quaternion","_vector3","_matrix4","_position","_rotation","_scale","vectorArrayToVector3","arr","x","y","z","rapierQuaternionToQuaternion","w","set","vector3ToRapierVector","v","Array","isArray","threeVector3","quaternionToRapierQuaternion","rigidBodyTypeMap","fixed","dynamic","kinematicPosition","kinematicVelocity","rigidBodyTypeFromString","type","scaleVertices","vertices","scale","scaledVerts","from","vectorToTuple","useConst","initialValue","ref","current","undefined","useRaf","callback","cb","raf","lastFrame","loop","now","performance","delta","requestAnimationFrame","cancelAnimationFrame","UseFrameStepper","onStep","updatePriority","_","dt","RafStepper","FrameStepper","createElement","FrameStepper$1","_objectWithoutPropertiesLoose","n","hasOwnProperty","includes","_objectWithoutProperties","s","propertyIsEnumerable","_excluded$2","scaleColliderArgs","shape","args","newArgs","slice","scaleArray","map","arg","index","createColliderFromOptions","options","world","getRigidBody","scaledArgs","desc","createCollider","immutableColliderOptions","massPropertiesConflictError","setColliderMassOptions","collider","density","mass","massProperties","Error","setDensity","setMass","setMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","mutableColliderOptions","sensor","setSensor","collisionGroups","setCollisionGroups","solverGroups","setSolverGroups","friction","setFriction","frictionCombineRule","setFrictionCombineRule","restitution","setRestitution","restitutionCombineRule","setRestitutionCombineRule","activeCollisionTypes","setActiveCollisionTypes","contactSkin","setContactSkin","quaternion","position","rotation","mutableColliderOptionKeys","setColliderOptions","states","state","get","handle","_state$worldParent","parentWorldScale","object","parent","getWorldScale","parentInvertedWorldMatrix","worldParent","matrixWorld","clone","invert","updateWorldMatrix","copy","premultiply","decompose","setTranslationWrtParent","setRotationWrtParent","setTranslation","setRotation","key","option","useUpdateColliderOptions","getCollider","props","mutablePropsAsFlatArray","flatMap","isChildOfMeshCollider","child","flag","traverseAncestors","a","userData","r3RapierType","createColliderState","rigidBodyObject","autoColliderMap","cuboid","ball","hull","trimesh","createColliderPropsFromChildren","ignoreMeshColliders","_ignoreMeshColliders","childColliderProps","invertedParentMatrixWorld","colliderFromChild","worldScale","colliders","rotationEuler","setFromQuaternion","geometry","offset","getColliderArgsFromGeometry","colliderProps","cleanRigidBodyPropsForCollider","includeInvisible","traverse","traverseVisible","computeBoundingBox","boundingBox","size","getSize","getCenter","computeBoundingSphere","boundingSphere","radius","center","_clonedGeometry$index","clonedGeometry","attributes","array","g","getActiveCollisionEventsFromProps","collision","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","contactForce","onContactForce","useColliderEvents","events","activeEvents","collisionEventsActive","contactForceEventsActive","hasCollisionEvent","hasContactForceEvent","setActiveEvents","COLLISION_EVENTS","CONTACT_FORCE_EVENTS","delete","rest","useMutableCallback","fn","useRapier","rapier","rapierContext","useBeforePhysicsStep","beforeStepCallbacks","add","useAfterPhysicsStep","afterStepCallbacks","useChildColliderProps","setColliderProps","Debug","mesh","buffers","debugRender","setAttribute","colors","frustumCulled","color","vertexColors","createSingletonProxy","createInstance","instance","handler","target","prop","Reflect","proxy","Proxy","reset","newInstance","getCollisionPayloadFromSource","other","_target$collider$stat","_target$rigidBody$sta","_other$collider$state","_other$rigidBody$stat","_other$collider$state2","_other$rigidBody$stat2","rigidBody","colliderObject","importRapier","init","Physics","children","timeStep","paused","interpolate","updateLoop","debug","gravity","allowedLinearError","predictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","contactNaturalFrequency","lengthUnit","invalidate","rigidBodyStates","Map","colliderStates","rigidBodyEvents","colliderEvents","eventQueue","Set","worldProxy","resetWorldProxy","setWorldProxy","World","free","integrationParameters","normalizedAllowedLinearError","normalizedPredictionDistance","contact_natural_frequency","getSourceFromColliderHandle","_collider$parent","colEvents","colliderState","rigidBodyHandle","rbEvents","rigidBodyState","source","steppingState","previousState","accumulator","step","timeStepVariable","clampedDelta","clamp","stepWorld","timestep","forEachRigidBody","body","translation","interpolationAlpha","onSleep","onWake","isSleeping","_events$onSleep","_events$onWake","setMatrix","compose","invertedWorldMatrix","meshType","lerp","slerp","drainCollisionEvents","handle1","handle2","started","source1","source2","collisionPayload1","collisionPayload2","contactPair","manifold","flipped","_source1$rigidBody$ev","_source1$rigidBody$ev2","_source2$rigidBody$ev","_source2$rigidBody$ev2","_source1$collider$eve","_source1$collider$eve2","_source2$collider$eve","_source2$collider$eve2","_source1$rigidBody$ev3","_source1$rigidBody$ev4","_source2$rigidBody$ev3","_source2$rigidBody$ev4","_source1$collider$eve3","_source1$collider$eve4","_source2$collider$eve3","_source2$collider$eve4","intersectionPair","_source1$rigidBody$ev5","_source1$rigidBody$ev6","_source2$rigidBody$ev5","_source2$rigidBody$ev6","_source1$collider$eve5","_source1$collider$eve6","_source2$collider$eve5","_source2$collider$eve6","_source1$rigidBody$ev7","_source1$rigidBody$ev8","_source2$rigidBody$ev7","_source2$rigidBody$ev8","_source1$collider$eve7","_source1$collider$eve8","_source2$collider$eve7","_source2$collider$eve8","drainContactForceEvents","event","_source1$rigidBody$ev9","_source1$rigidBody$ev10","_source2$rigidBody$ev9","_source2$rigidBody$ev10","_source1$collider$eve9","_source1$collider$eve10","_source2$collider$eve9","_source2$collider$eve10","collider1","collider2","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","forEachActiveRigidBody","context","setWorld","physicsOptions","isPaused","isDebug","stepCallback","Provider","_extends","assign","bind","useImperativeInstance","createFn","destroyFn","dependencyList","getInstance","destroy","vec3","quat","euler","useForwardedRef","forwardedRef","defaultValue","innerRef","AnyCollider","name","rigidBodyContext","useRigidBodyContext","colliderRef","objectRef","immutablePropArray","removeCollider","mergedProps","CuboidCollider","displayName","RoundCuboidCollider","BallCollider","CapsuleCollider","HeightfieldCollider","TrimeshCollider","ConeCollider","RoundConeCollider","CylinderCollider","RoundCylinderCollider","ConvexHullCollider","rigidBodyDescFromOptions","_options$canSleep","canSleep","createRigidBodyState","getMatrix","_meshType","matrix","immutableRigidBodyOptions","mutableRigidBodyOptions","gravityScale","rb","setGravityScale","additionalSolverIterations","setAdditionalSolverIterations","linearDamping","setLinearDamping","angularDamping","setAngularDamping","dominanceGroup","setDominanceGroup","enabledRotations","setEnabledRotations","enabledTranslations","setEnabledTranslations","lockRotations","lockTranslations","angularVelocity","setAngvel","linearVelocity","setLinvel","ccd","enableCcd","softCcdPrediction","setSoftCcdPrediction","setBodyType","mutableRigidBodyOptionKeys","setRigidBodyOptions","updateTranslations","useUpdateRigidBodyOptions","useRigidBodyEvents","eventHandlers","_excluded$1","RigidBodyContext","transformState","objectProps","rigidBodyRef","mergedOptions","createRigidBody","removeRigidBody","contextValue","MeshCollider","_excluded","InstancedRigidBodies","rigidBodiesRef","instanceWrapperRef","instances","colliderNodes","rigidBodyProps","getInstancedMesh","firstChild","instancedMesh","instanceMatrix","setUsage","console","warn","applyInstancedState","getMatrixAt","setMatrixAt","needsUpdate","node","colliderIndex","useImpulseJoint","body1","body2","params","jointRef","newJoint","createImpulseJoint","joint","getImpulseJoint","removeImpulseJoint","useFixedJoint","body1Anchor","body1LocalFrame","body2Anchor","body2LocalFrame","JointData","useSphericalJoint","spherical","useRevoluteJoint","axis","limits","revolute","limitsEnabled","usePrismaticJoint","prismatic","useRopeJoint","vBody1Anchor","vBody2Anchor","rope","useSpringJoint","restLength","stiffness","damping","spring","interactionGroups","memberships","filters","bitmask","groups","flat","reduce","acc","layer"],"sources":["C:/Users/subha/Downloads/ma/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}