{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\subha\\\\Downloads\\\\ma\\\\src\\\\components\\\\PlayerController.tsx\",\n  _s = $RefreshSig$();\nimport { useRef, useEffect } from 'react';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { RigidBody, useRapier } from '@react-three/rapier';\nimport { PointerLockControls } from '@react-three/drei';\nimport { Vector3, Euler } from 'three';\nimport { useKeyboard } from '../hooks/useKeyboard';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const PlayerController = ({\n  position\n}) => {\n  _s();\n  const playerRef = useRef(null);\n  const controlsRef = useRef(null);\n  const {\n    camera\n  } = useThree();\n  const {\n    world\n  } = useRapier();\n  const keys = useKeyboard();\n\n  // Professional movement constants - exactly as specified\n  const SPEED = 2.5; // units/second\n  const FRICTION = 8; // deceleration friction\n  const PLAYER_HEIGHT = 1.6; // meters\n  const PLAYER_RADIUS = 0.4; // meters\n  const CAMERA_HEIGHT_OFFSET = 1.5; // units\n\n  // Movement state\n  const velocity = useRef(new Vector3(0, 0, 0));\n  const distanceWalked = useRef(0);\n  const lastPosition = useRef(new Vector3(...position));\n  useEffect(() => {\n    // Set initial camera position\n    camera.position.set(position[0], position[1] + CAMERA_HEIGHT_OFFSET, position[2]);\n  }, [camera, position]);\n\n  // Professional collision probe using Rapier's shapeCast\n  const collisionProbe = testPosition => {\n    if (!world || !playerRef.current) return false;\n    try {\n      // Create capsule shape for collision testing\n      const shape = world.createCollider({\n        type: 'capsule',\n        radius: PLAYER_RADIUS,\n        halfHeight: PLAYER_HEIGHT / 2\n      });\n\n      // Cast the shape at the test position\n      const hit = world.castShape(testPosition, new Euler(0, 0, 0), new Vector3(0, 0, 0), shape, 0.01,\n      // small probe distance\n      true, undefined, undefined, playerRef.current);\n      shape.free();\n      return hit !== null;\n    } catch {\n      // Fallback to simple grid-based collision\n      const gridX = Math.floor(testPosition.x);\n      const gridZ = Math.floor(testPosition.z);\n\n      // Simple maze bounds check\n      if (gridX < 1 || gridX > 13 || gridZ < 1 || gridZ > 13) return true;\n      return false;\n    }\n  };\n\n  // Head bob effect\n  const headBob = useRef({\n    phase: 0,\n    amplitude: 0.02\n  });\n  useFrame((_, delta) => {\n    if (!playerRef.current) return;\n\n    // Get current position\n    const currentPos = playerRef.current.translation();\n    const currentPosition = new Vector3(currentPos.x, currentPos.y, currentPos.z);\n\n    // Calculate movement direction from input\n    const direction = new Vector3(0, 0, 0);\n    if (keys.forward) direction.z -= 1; // W / Up Arrow\n    if (keys.backward) direction.z += 1; // S / Down Arrow  \n    if (keys.left) direction.x -= 1; // A / Left Arrow\n    if (keys.right) direction.x += 1; // D / Right Arrow\n\n    // Normalize direction for consistent speed\n    if (direction.length() > 0) {\n      direction.normalize();\n    }\n\n    // Apply camera yaw to world space movement\n    const yaw = camera.rotation.y;\n    const worldDirection = new Vector3(direction.x * Math.cos(yaw) - direction.z * Math.sin(yaw), 0, direction.z * Math.cos(yaw) + direction.x * Math.sin(yaw));\n\n    // Calculate intended movement\n    const intendedMove = worldDirection.multiplyScalar(SPEED * delta);\n\n    // Apply smooth deceleration friction\n    const frictionFactor = Math.pow(1 - FRICTION * delta, delta);\n    velocity.current.multiplyScalar(frictionFactor);\n\n    // Add new movement to velocity (smooth acceleration)\n    velocity.current.add(intendedMove);\n\n    // Precise anti-clipping algorithm\n    let finalMove = new Vector3(0, 0, 0);\n\n    // Check X movement separately\n    const testPosX = currentPosition.clone().add(new Vector3(velocity.current.x, 0, 0));\n    if (!collisionProbe(testPosX)) {\n      finalMove.x = velocity.current.x;\n    } else {\n      velocity.current.x = 0; // Stop X movement on collision\n    }\n\n    // Check Z movement separately  \n    const testPosZ = currentPosition.clone().add(new Vector3(0, 0, velocity.current.z));\n    if (!collisionProbe(testPosZ)) {\n      finalMove.z = velocity.current.z;\n    } else {\n      velocity.current.z = 0; // Stop Z movement on collision\n    }\n\n    // Apply final movement to rigid body\n    const finalPosition = currentPosition.add(finalMove);\n    playerRef.current.setNextKinematicTranslation({\n      x: finalPosition.x,\n      y: finalPosition.y,\n      z: finalPosition.z\n    });\n\n    // Track distance walked for footsteps\n    const movementDistance = finalMove.length();\n    distanceWalked.current += movementDistance;\n\n    // Head bob effect when moving\n    if (movementDistance > 0.001) {\n      headBob.current.phase += movementDistance * 10;\n      const bobOffset = Math.sin(headBob.current.phase) * headBob.current.amplitude;\n\n      // Sync camera position with head bob\n      camera.position.set(finalPosition.x, finalPosition.y + CAMERA_HEIGHT_OFFSET + bobOffset, finalPosition.z);\n\n      // Simple footstep sound trigger (every 1.5 units walked)\n      if (Math.floor(distanceWalked.current / 1.5) > Math.floor((distanceWalked.current - movementDistance) / 1.5)) {\n        // Trigger footstep sound here\n        console.log('Footstep'); // Replace with actual audio\n      }\n    } else {\n      // No movement - sync camera without bob\n      camera.position.set(finalPosition.x, finalPosition.y + CAMERA_HEIGHT_OFFSET, finalPosition.z);\n    }\n    lastPosition.current.copy(finalPosition);\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(PointerLockControls, {\n      ref: controlsRef,\n      camera: camera,\n      domElement: document.body,\n      maxPolarAngle: Math.PI / 2 - 0.087 // +85 degrees\n      ,\n      minPolarAngle: -Math.PI / 2 + 0.087 // -85 degrees\n      ,\n      pointerSpeed: 0.5 // Smooth mouse movement\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RigidBody, {\n      ref: playerRef,\n      type: \"kinematicPosition\",\n      position: position,\n      colliders: false,\n      gravityScale: 0,\n      children: /*#__PURE__*/_jsxDEV(\"mesh\", {\n        visible: false,\n        children: [/*#__PURE__*/_jsxDEV(\"capsuleGeometry\", {\n          args: [PLAYER_RADIUS, PLAYER_HEIGHT]\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 196,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"meshBasicMaterial\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 197,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 195,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 187,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(PlayerController, \"0VlVSpImWddAIeUEGaXAbUDmLs4=\", false, function () {\n  return [useThree, useRapier, useKeyboard, useFrame];\n});\n_c = PlayerController;\nvar _c;\n$RefreshReg$(_c, \"PlayerController\");","map":{"version":3,"names":["useRef","useEffect","useFrame","useThree","RigidBody","useRapier","PointerLockControls","Vector3","Euler","useKeyboard","jsxDEV","_jsxDEV","Fragment","_Fragment","PlayerController","position","_s","playerRef","controlsRef","camera","world","keys","SPEED","FRICTION","PLAYER_HEIGHT","PLAYER_RADIUS","CAMERA_HEIGHT_OFFSET","velocity","distanceWalked","lastPosition","set","collisionProbe","testPosition","current","shape","createCollider","type","radius","halfHeight","hit","castShape","undefined","free","gridX","Math","floor","x","gridZ","z","headBob","phase","amplitude","_","delta","currentPos","translation","currentPosition","y","direction","forward","backward","left","right","length","normalize","yaw","rotation","worldDirection","cos","sin","intendedMove","multiplyScalar","frictionFactor","pow","add","finalMove","testPosX","clone","testPosZ","finalPosition","setNextKinematicTranslation","movementDistance","bobOffset","console","log","copy","children","ref","domElement","document","body","maxPolarAngle","PI","minPolarAngle","pointerSpeed","fileName","_jsxFileName","lineNumber","columnNumber","colliders","gravityScale","visible","args","_c","$RefreshReg$"],"sources":["C:/Users/subha/Downloads/ma/src/components/PlayerController.tsx"],"sourcesContent":["import { useRef, useEffect } from 'react';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\nimport { RigidBody, RapierRigidBody, useRapier } from '@react-three/rapier';\r\nimport { PointerLockControls } from '@react-three/drei';\r\nimport { Vector3, Euler } from 'three';\r\nimport { useKeyboard } from '../hooks/useKeyboard';\r\n\r\ninterface PlayerControllerProps {\r\n  position: [number, number, number];\r\n}\r\n\r\nexport const PlayerController: React.FC<PlayerControllerProps> = ({ position }) => {\r\n  const playerRef = useRef<RapierRigidBody>(null);\r\n  const controlsRef = useRef<any>(null);\r\n  const { camera } = useThree();\r\n  const { world } = useRapier();\r\n  const keys = useKeyboard();\r\n\r\n  // Professional movement constants - exactly as specified\r\n  const SPEED = 2.5; // units/second\r\n  const FRICTION = 8; // deceleration friction\r\n  const PLAYER_HEIGHT = 1.6; // meters\r\n  const PLAYER_RADIUS = 0.4; // meters\r\n  const CAMERA_HEIGHT_OFFSET = 1.5; // units\r\n\r\n  // Movement state\r\n  const velocity = useRef(new Vector3(0, 0, 0));\r\n  const distanceWalked = useRef(0);\r\n  const lastPosition = useRef(new Vector3(...position));\r\n\r\n  useEffect(() => {\r\n    // Set initial camera position\r\n    camera.position.set(position[0], position[1] + CAMERA_HEIGHT_OFFSET, position[2]);\r\n  }, [camera, position]);\r\n\r\n  // Professional collision probe using Rapier's shapeCast\r\n  const collisionProbe = (testPosition: Vector3): boolean => {\r\n    if (!world || !playerRef.current) return false;\r\n\r\n    try {\r\n      // Create capsule shape for collision testing\r\n      const shape = world.createCollider({\r\n        type: 'capsule',\r\n        radius: PLAYER_RADIUS,\r\n        halfHeight: PLAYER_HEIGHT / 2,\r\n      });\r\n\r\n      // Cast the shape at the test position\r\n      const hit = world.castShape(\r\n        testPosition,\r\n        new Euler(0, 0, 0),\r\n        new Vector3(0, 0, 0),\r\n        shape,\r\n        0.01, // small probe distance\r\n        true,\r\n        undefined,\r\n        undefined,\r\n        playerRef.current\r\n      );\r\n\r\n      shape.free();\r\n      return hit !== null;\r\n    } catch {\r\n      // Fallback to simple grid-based collision\r\n      const gridX = Math.floor(testPosition.x);\r\n      const gridZ = Math.floor(testPosition.z);\r\n      \r\n      // Simple maze bounds check\r\n      if (gridX < 1 || gridX > 13 || gridZ < 1 || gridZ > 13) return true;\r\n      \r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Head bob effect\r\n  const headBob = useRef({ phase: 0, amplitude: 0.02 });\r\n\r\n  useFrame((_, delta) => {\r\n    if (!playerRef.current) return;\r\n\r\n    // Get current position\r\n    const currentPos = playerRef.current.translation();\r\n    const currentPosition = new Vector3(currentPos.x, currentPos.y, currentPos.z);\r\n\r\n    // Calculate movement direction from input\r\n    const direction = new Vector3(0, 0, 0);\r\n    \r\n    if (keys.forward) direction.z -= 1;   // W / Up Arrow\r\n    if (keys.backward) direction.z += 1;  // S / Down Arrow  \r\n    if (keys.left) direction.x -= 1;      // A / Left Arrow\r\n    if (keys.right) direction.x += 1;     // D / Right Arrow\r\n\r\n    // Normalize direction for consistent speed\r\n    if (direction.length() > 0) {\r\n      direction.normalize();\r\n    }\r\n\r\n    // Apply camera yaw to world space movement\r\n    const yaw = camera.rotation.y;\r\n    const worldDirection = new Vector3(\r\n      direction.x * Math.cos(yaw) - direction.z * Math.sin(yaw),\r\n      0,\r\n      direction.z * Math.cos(yaw) + direction.x * Math.sin(yaw)\r\n    );\r\n\r\n    // Calculate intended movement\r\n    const intendedMove = worldDirection.multiplyScalar(SPEED * delta);\r\n\r\n    // Apply smooth deceleration friction\r\n    const frictionFactor = Math.pow(1 - FRICTION * delta, delta);\r\n    velocity.current.multiplyScalar(frictionFactor);\r\n\r\n    // Add new movement to velocity (smooth acceleration)\r\n    velocity.current.add(intendedMove);\r\n\r\n    // Precise anti-clipping algorithm\r\n    let finalMove = new Vector3(0, 0, 0);\r\n\r\n    // Check X movement separately\r\n    const testPosX = currentPosition.clone().add(new Vector3(velocity.current.x, 0, 0));\r\n    if (!collisionProbe(testPosX)) {\r\n      finalMove.x = velocity.current.x;\r\n    } else {\r\n      velocity.current.x = 0; // Stop X movement on collision\r\n    }\r\n\r\n    // Check Z movement separately  \r\n    const testPosZ = currentPosition.clone().add(new Vector3(0, 0, velocity.current.z));\r\n    if (!collisionProbe(testPosZ)) {\r\n      finalMove.z = velocity.current.z;\r\n    } else {\r\n      velocity.current.z = 0; // Stop Z movement on collision\r\n    }\r\n\r\n    // Apply final movement to rigid body\r\n    const finalPosition = currentPosition.add(finalMove);\r\n    playerRef.current.setNextKinematicTranslation({\r\n      x: finalPosition.x,\r\n      y: finalPosition.y,\r\n      z: finalPosition.z,\r\n    });\r\n\r\n    // Track distance walked for footsteps\r\n    const movementDistance = finalMove.length();\r\n    distanceWalked.current += movementDistance;\r\n\r\n    // Head bob effect when moving\r\n    if (movementDistance > 0.001) {\r\n      headBob.current.phase += movementDistance * 10;\r\n      const bobOffset = Math.sin(headBob.current.phase) * headBob.current.amplitude;\r\n      \r\n      // Sync camera position with head bob\r\n      camera.position.set(\r\n        finalPosition.x,\r\n        finalPosition.y + CAMERA_HEIGHT_OFFSET + bobOffset,\r\n        finalPosition.z\r\n      );\r\n\r\n      // Simple footstep sound trigger (every 1.5 units walked)\r\n      if (Math.floor(distanceWalked.current / 1.5) > Math.floor((distanceWalked.current - movementDistance) / 1.5)) {\r\n        // Trigger footstep sound here\r\n        console.log('Footstep'); // Replace with actual audio\r\n      }\r\n    } else {\r\n      // No movement - sync camera without bob\r\n      camera.position.set(\r\n        finalPosition.x,\r\n        finalPosition.y + CAMERA_HEIGHT_OFFSET,\r\n        finalPosition.z\r\n      );\r\n    }\r\n\r\n    lastPosition.current.copy(finalPosition);\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <PointerLockControls\r\n        ref={controlsRef}\r\n        camera={camera}\r\n        domElement={document.body}\r\n        maxPolarAngle={Math.PI / 2 - 0.087} // +85 degrees\r\n        minPolarAngle={-Math.PI / 2 + 0.087} // -85 degrees\r\n        pointerSpeed={0.5} // Smooth mouse movement\r\n      />\r\n      \r\n      <RigidBody\r\n        ref={playerRef}\r\n        type=\"kinematicPosition\"\r\n        position={position}\r\n        colliders={false}\r\n        gravityScale={0}\r\n      >\r\n        {/* Capsule collider for player */}\r\n        <mesh visible={false}>\r\n          <capsuleGeometry args={[PLAYER_RADIUS, PLAYER_HEIGHT]} />\r\n          <meshBasicMaterial />\r\n        </mesh>\r\n      </RigidBody>\r\n    </>\r\n  );\r\n};"],"mappings":";;AAAA,SAASA,MAAM,EAAEC,SAAS,QAAQ,OAAO;AACzC,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,oBAAoB;AACvD,SAASC,SAAS,EAAmBC,SAAS,QAAQ,qBAAqB;AAC3E,SAASC,mBAAmB,QAAQ,mBAAmB;AACvD,SAASC,OAAO,EAAEC,KAAK,QAAQ,OAAO;AACtC,SAASC,WAAW,QAAQ,sBAAsB;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AAMnD,OAAO,MAAMC,gBAAiD,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EACjF,MAAMC,SAAS,GAAGjB,MAAM,CAAkB,IAAI,CAAC;EAC/C,MAAMkB,WAAW,GAAGlB,MAAM,CAAM,IAAI,CAAC;EACrC,MAAM;IAAEmB;EAAO,CAAC,GAAGhB,QAAQ,CAAC,CAAC;EAC7B,MAAM;IAAEiB;EAAM,CAAC,GAAGf,SAAS,CAAC,CAAC;EAC7B,MAAMgB,IAAI,GAAGZ,WAAW,CAAC,CAAC;;EAE1B;EACA,MAAMa,KAAK,GAAG,GAAG,CAAC,CAAC;EACnB,MAAMC,QAAQ,GAAG,CAAC,CAAC,CAAC;EACpB,MAAMC,aAAa,GAAG,GAAG,CAAC,CAAC;EAC3B,MAAMC,aAAa,GAAG,GAAG,CAAC,CAAC;EAC3B,MAAMC,oBAAoB,GAAG,GAAG,CAAC,CAAC;;EAElC;EACA,MAAMC,QAAQ,GAAG3B,MAAM,CAAC,IAAIO,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC7C,MAAMqB,cAAc,GAAG5B,MAAM,CAAC,CAAC,CAAC;EAChC,MAAM6B,YAAY,GAAG7B,MAAM,CAAC,IAAIO,OAAO,CAAC,GAAGQ,QAAQ,CAAC,CAAC;EAErDd,SAAS,CAAC,MAAM;IACd;IACAkB,MAAM,CAACJ,QAAQ,CAACe,GAAG,CAACf,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,GAAGW,oBAAoB,EAAEX,QAAQ,CAAC,CAAC,CAAC,CAAC;EACnF,CAAC,EAAE,CAACI,MAAM,EAAEJ,QAAQ,CAAC,CAAC;;EAEtB;EACA,MAAMgB,cAAc,GAAIC,YAAqB,IAAc;IACzD,IAAI,CAACZ,KAAK,IAAI,CAACH,SAAS,CAACgB,OAAO,EAAE,OAAO,KAAK;IAE9C,IAAI;MACF;MACA,MAAMC,KAAK,GAAGd,KAAK,CAACe,cAAc,CAAC;QACjCC,IAAI,EAAE,SAAS;QACfC,MAAM,EAAEZ,aAAa;QACrBa,UAAU,EAAEd,aAAa,GAAG;MAC9B,CAAC,CAAC;;MAEF;MACA,MAAMe,GAAG,GAAGnB,KAAK,CAACoB,SAAS,CACzBR,YAAY,EACZ,IAAIxB,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAClB,IAAID,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACpB2B,KAAK,EACL,IAAI;MAAE;MACN,IAAI,EACJO,SAAS,EACTA,SAAS,EACTxB,SAAS,CAACgB,OACZ,CAAC;MAEDC,KAAK,CAACQ,IAAI,CAAC,CAAC;MACZ,OAAOH,GAAG,KAAK,IAAI;IACrB,CAAC,CAAC,MAAM;MACN;MACA,MAAMI,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACb,YAAY,CAACc,CAAC,CAAC;MACxC,MAAMC,KAAK,GAAGH,IAAI,CAACC,KAAK,CAACb,YAAY,CAACgB,CAAC,CAAC;;MAExC;MACA,IAAIL,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,EAAE,IAAII,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,EAAE,EAAE,OAAO,IAAI;MAEnE,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAME,OAAO,GAAGjD,MAAM,CAAC;IAAEkD,KAAK,EAAE,CAAC;IAAEC,SAAS,EAAE;EAAK,CAAC,CAAC;EAErDjD,QAAQ,CAAC,CAACkD,CAAC,EAAEC,KAAK,KAAK;IACrB,IAAI,CAACpC,SAAS,CAACgB,OAAO,EAAE;;IAExB;IACA,MAAMqB,UAAU,GAAGrC,SAAS,CAACgB,OAAO,CAACsB,WAAW,CAAC,CAAC;IAClD,MAAMC,eAAe,GAAG,IAAIjD,OAAO,CAAC+C,UAAU,CAACR,CAAC,EAAEQ,UAAU,CAACG,CAAC,EAAEH,UAAU,CAACN,CAAC,CAAC;;IAE7E;IACA,MAAMU,SAAS,GAAG,IAAInD,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAEtC,IAAIc,IAAI,CAACsC,OAAO,EAAED,SAAS,CAACV,CAAC,IAAI,CAAC,CAAC,CAAG;IACtC,IAAI3B,IAAI,CAACuC,QAAQ,EAAEF,SAAS,CAACV,CAAC,IAAI,CAAC,CAAC,CAAE;IACtC,IAAI3B,IAAI,CAACwC,IAAI,EAAEH,SAAS,CAACZ,CAAC,IAAI,CAAC,CAAC,CAAM;IACtC,IAAIzB,IAAI,CAACyC,KAAK,EAAEJ,SAAS,CAACZ,CAAC,IAAI,CAAC,CAAC,CAAK;;IAEtC;IACA,IAAIY,SAAS,CAACK,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE;MAC1BL,SAAS,CAACM,SAAS,CAAC,CAAC;IACvB;;IAEA;IACA,MAAMC,GAAG,GAAG9C,MAAM,CAAC+C,QAAQ,CAACT,CAAC;IAC7B,MAAMU,cAAc,GAAG,IAAI5D,OAAO,CAChCmD,SAAS,CAACZ,CAAC,GAAGF,IAAI,CAACwB,GAAG,CAACH,GAAG,CAAC,GAAGP,SAAS,CAACV,CAAC,GAAGJ,IAAI,CAACyB,GAAG,CAACJ,GAAG,CAAC,EACzD,CAAC,EACDP,SAAS,CAACV,CAAC,GAAGJ,IAAI,CAACwB,GAAG,CAACH,GAAG,CAAC,GAAGP,SAAS,CAACZ,CAAC,GAAGF,IAAI,CAACyB,GAAG,CAACJ,GAAG,CAC1D,CAAC;;IAED;IACA,MAAMK,YAAY,GAAGH,cAAc,CAACI,cAAc,CAACjD,KAAK,GAAG+B,KAAK,CAAC;;IAEjE;IACA,MAAMmB,cAAc,GAAG5B,IAAI,CAAC6B,GAAG,CAAC,CAAC,GAAGlD,QAAQ,GAAG8B,KAAK,EAAEA,KAAK,CAAC;IAC5D1B,QAAQ,CAACM,OAAO,CAACsC,cAAc,CAACC,cAAc,CAAC;;IAE/C;IACA7C,QAAQ,CAACM,OAAO,CAACyC,GAAG,CAACJ,YAAY,CAAC;;IAElC;IACA,IAAIK,SAAS,GAAG,IAAIpE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAEpC;IACA,MAAMqE,QAAQ,GAAGpB,eAAe,CAACqB,KAAK,CAAC,CAAC,CAACH,GAAG,CAAC,IAAInE,OAAO,CAACoB,QAAQ,CAACM,OAAO,CAACa,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACnF,IAAI,CAACf,cAAc,CAAC6C,QAAQ,CAAC,EAAE;MAC7BD,SAAS,CAAC7B,CAAC,GAAGnB,QAAQ,CAACM,OAAO,CAACa,CAAC;IAClC,CAAC,MAAM;MACLnB,QAAQ,CAACM,OAAO,CAACa,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1B;;IAEA;IACA,MAAMgC,QAAQ,GAAGtB,eAAe,CAACqB,KAAK,CAAC,CAAC,CAACH,GAAG,CAAC,IAAInE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAEoB,QAAQ,CAACM,OAAO,CAACe,CAAC,CAAC,CAAC;IACnF,IAAI,CAACjB,cAAc,CAAC+C,QAAQ,CAAC,EAAE;MAC7BH,SAAS,CAAC3B,CAAC,GAAGrB,QAAQ,CAACM,OAAO,CAACe,CAAC;IAClC,CAAC,MAAM;MACLrB,QAAQ,CAACM,OAAO,CAACe,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1B;;IAEA;IACA,MAAM+B,aAAa,GAAGvB,eAAe,CAACkB,GAAG,CAACC,SAAS,CAAC;IACpD1D,SAAS,CAACgB,OAAO,CAAC+C,2BAA2B,CAAC;MAC5ClC,CAAC,EAAEiC,aAAa,CAACjC,CAAC;MAClBW,CAAC,EAAEsB,aAAa,CAACtB,CAAC;MAClBT,CAAC,EAAE+B,aAAa,CAAC/B;IACnB,CAAC,CAAC;;IAEF;IACA,MAAMiC,gBAAgB,GAAGN,SAAS,CAACZ,MAAM,CAAC,CAAC;IAC3CnC,cAAc,CAACK,OAAO,IAAIgD,gBAAgB;;IAE1C;IACA,IAAIA,gBAAgB,GAAG,KAAK,EAAE;MAC5BhC,OAAO,CAAChB,OAAO,CAACiB,KAAK,IAAI+B,gBAAgB,GAAG,EAAE;MAC9C,MAAMC,SAAS,GAAGtC,IAAI,CAACyB,GAAG,CAACpB,OAAO,CAAChB,OAAO,CAACiB,KAAK,CAAC,GAAGD,OAAO,CAAChB,OAAO,CAACkB,SAAS;;MAE7E;MACAhC,MAAM,CAACJ,QAAQ,CAACe,GAAG,CACjBiD,aAAa,CAACjC,CAAC,EACfiC,aAAa,CAACtB,CAAC,GAAG/B,oBAAoB,GAAGwD,SAAS,EAClDH,aAAa,CAAC/B,CAChB,CAAC;;MAED;MACA,IAAIJ,IAAI,CAACC,KAAK,CAACjB,cAAc,CAACK,OAAO,GAAG,GAAG,CAAC,GAAGW,IAAI,CAACC,KAAK,CAAC,CAACjB,cAAc,CAACK,OAAO,GAAGgD,gBAAgB,IAAI,GAAG,CAAC,EAAE;QAC5G;QACAE,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;MAC3B;IACF,CAAC,MAAM;MACL;MACAjE,MAAM,CAACJ,QAAQ,CAACe,GAAG,CACjBiD,aAAa,CAACjC,CAAC,EACfiC,aAAa,CAACtB,CAAC,GAAG/B,oBAAoB,EACtCqD,aAAa,CAAC/B,CAChB,CAAC;IACH;IAEAnB,YAAY,CAACI,OAAO,CAACoD,IAAI,CAACN,aAAa,CAAC;EAC1C,CAAC,CAAC;EAEF,oBACEpE,OAAA,CAAAE,SAAA;IAAAyE,QAAA,gBACE3E,OAAA,CAACL,mBAAmB;MAClBiF,GAAG,EAAErE,WAAY;MACjBC,MAAM,EAAEA,MAAO;MACfqE,UAAU,EAAEC,QAAQ,CAACC,IAAK;MAC1BC,aAAa,EAAE/C,IAAI,CAACgD,EAAE,GAAG,CAAC,GAAG,KAAM,CAAC;MAAA;MACpCC,aAAa,EAAE,CAACjD,IAAI,CAACgD,EAAE,GAAG,CAAC,GAAG,KAAM,CAAC;MAAA;MACrCE,YAAY,EAAE,GAAI,CAAC;IAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACpB,CAAC,eAEFvF,OAAA,CAACP,SAAS;MACRmF,GAAG,EAAEtE,SAAU;MACfmB,IAAI,EAAC,mBAAmB;MACxBrB,QAAQ,EAAEA,QAAS;MACnBoF,SAAS,EAAE,KAAM;MACjBC,YAAY,EAAE,CAAE;MAAAd,QAAA,eAGhB3E,OAAA;QAAM0F,OAAO,EAAE,KAAM;QAAAf,QAAA,gBACnB3E,OAAA;UAAiB2F,IAAI,EAAE,CAAC7E,aAAa,EAAED,aAAa;QAAE;UAAAuE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC,eACzDvF,OAAA;UAAAoF,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAoB,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACjB;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC;EAAA,eACZ,CAAC;AAEP,CAAC;AAAClF,EAAA,CA9LWF,gBAAiD;EAAA,QAGzCX,QAAQ,EACTE,SAAS,EACdI,WAAW,EA6DxBP,QAAQ;AAAA;AAAAqG,EAAA,GAlEGzF,gBAAiD;AAAA,IAAAyF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}