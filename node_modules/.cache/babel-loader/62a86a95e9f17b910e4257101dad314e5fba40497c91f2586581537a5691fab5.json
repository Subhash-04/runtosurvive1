{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\subha\\\\Downloads\\\\ma\\\\src\\\\components\\\\PlayerController.tsx\",\n  _s = $RefreshSig$();\nimport { useRef, useEffect } from 'react';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { RigidBody, useRapier } from '@react-three/rapier';\nimport { PointerLockControls } from '@react-three/drei';\nimport { Vector3 } from 'three';\nimport { useKeyboard } from '../hooks/useKeyboard';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const PlayerController = ({\n  position\n}) => {\n  _s();\n  const playerRef = useRef(null);\n  const controlsRef = useRef(null);\n  const {\n    camera\n  } = useThree();\n  const {\n    world\n  } = useRapier();\n  const keys = useKeyboard();\n\n  // Professional movement constants - exactly as specified\n  const SPEED = 2.5; // units/second\n  const FRICTION = 8; // deceleration friction\n  const PLAYER_HEIGHT = 1.6; // meters\n  const PLAYER_RADIUS = 0.4; // meters\n  const CAMERA_HEIGHT_OFFSET = 1.5; // units\n\n  // Movement state\n  const velocity = useRef(new Vector3(0, 0, 0));\n  const distanceWalked = useRef(0);\n  const lastPosition = useRef(new Vector3(...position));\n  useEffect(() => {\n    // Set initial camera position\n    camera.position.set(position[0], position[1] + CAMERA_HEIGHT_OFFSET, position[2]);\n  }, [camera, position]);\n\n  // Professional collision probe using Rapier's ray casting\n  const collisionProbe = testPosition => {\n    if (!world || !playerRef.current) return false;\n    try {\n      // Use multiple ray casts to simulate capsule collision\n      const directions = [{\n        x: 1,\n        y: 0,\n        z: 0\n      },\n      // right\n      {\n        x: -1,\n        y: 0,\n        z: 0\n      },\n      // left\n      {\n        x: 0,\n        y: 0,\n        z: 1\n      },\n      // forward\n      {\n        x: 0,\n        y: 0,\n        z: -1\n      } // backward\n      ];\n      for (const dir of directions) {\n        const ray = world.castRay({\n          x: testPosition.x,\n          y: testPosition.y + PLAYER_HEIGHT / 2,\n          z: testPosition.z\n        }, dir, PLAYER_RADIUS + 0.1, true, undefined, undefined, playerRef.current);\n        if (ray) return true;\n      }\n      return false;\n    } catch {\n      // Fallback to grid-based collision detection\n      const effectiveRadius = PLAYER_RADIUS * 0.8;\n\n      // Check 4 corners of player bounding box\n      const points = [{\n        x: testPosition.x + effectiveRadius,\n        z: testPosition.z + effectiveRadius\n      }, {\n        x: testPosition.x + effectiveRadius,\n        z: testPosition.z - effectiveRadius\n      }, {\n        x: testPosition.x - effectiveRadius,\n        z: testPosition.z + effectiveRadius\n      }, {\n        x: testPosition.x - effectiveRadius,\n        z: testPosition.z - effectiveRadius\n      }];\n\n      // Simple maze layout for fallback collision\n      const maze = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];\n      for (const point of points) {\n        const gridX = Math.floor(point.x);\n        const gridZ = Math.floor(point.z);\n\n        // Check boundaries\n        if (gridZ < 0 || gridZ >= maze.length || gridX < 0 || gridX >= maze[0].length) {\n          return true;\n        }\n\n        // Check wall collision\n        if (maze[gridZ][gridX] === 1) {\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n\n  // Head bob effect\n  const headBob = useRef({\n    phase: 0,\n    amplitude: 0.02\n  });\n  useFrame((_, delta) => {\n    if (!playerRef.current) return;\n\n    // Get current position\n    const currentPos = playerRef.current.translation();\n    const currentPosition = new Vector3(currentPos.x, currentPos.y, currentPos.z);\n\n    // Calculate movement direction from input\n    const direction = new Vector3(0, 0, 0);\n    if (keys.forward) direction.z -= 1; // W / Up Arrow\n    if (keys.backward) direction.z += 1; // S / Down Arrow  \n    if (keys.left) direction.x -= 1; // A / Left Arrow\n    if (keys.right) direction.x += 1; // D / Right Arrow\n\n    // Normalize direction for consistent speed\n    if (direction.length() > 0) {\n      direction.normalize();\n    }\n\n    // Apply camera yaw to world space movement\n    const yaw = camera.rotation.y;\n    const worldDirection = new Vector3(direction.x * Math.cos(yaw) - direction.z * Math.sin(yaw), 0, direction.z * Math.cos(yaw) + direction.x * Math.sin(yaw));\n\n    // Calculate intended movement\n    const intendedMove = worldDirection.multiplyScalar(SPEED * delta);\n\n    // Apply smooth deceleration friction\n    const frictionFactor = Math.pow(1 - FRICTION * delta, delta);\n    velocity.current.multiplyScalar(frictionFactor);\n\n    // Add new movement to velocity (smooth acceleration)\n    velocity.current.add(intendedMove);\n\n    // Precise anti-clipping algorithm\n    let finalMove = new Vector3(0, 0, 0);\n\n    // Check X movement separately\n    const testPosX = currentPosition.clone().add(new Vector3(velocity.current.x, 0, 0));\n    if (!collisionProbe(testPosX)) {\n      finalMove.x = velocity.current.x;\n    } else {\n      velocity.current.x = 0; // Stop X movement on collision\n    }\n\n    // Check Z movement separately  \n    const testPosZ = currentPosition.clone().add(new Vector3(0, 0, velocity.current.z));\n    if (!collisionProbe(testPosZ)) {\n      finalMove.z = velocity.current.z;\n    } else {\n      velocity.current.z = 0; // Stop Z movement on collision\n    }\n\n    // Apply final movement to rigid body\n    const finalPosition = currentPosition.add(finalMove);\n    playerRef.current.setNextKinematicTranslation({\n      x: finalPosition.x,\n      y: finalPosition.y,\n      z: finalPosition.z\n    });\n\n    // Track distance walked for footsteps\n    const movementDistance = finalMove.length();\n    distanceWalked.current += movementDistance;\n\n    // Head bob effect when moving\n    if (movementDistance > 0.001) {\n      headBob.current.phase += movementDistance * 10;\n      const bobOffset = Math.sin(headBob.current.phase) * headBob.current.amplitude;\n\n      // Sync camera position with head bob\n      camera.position.set(finalPosition.x, finalPosition.y + CAMERA_HEIGHT_OFFSET + bobOffset, finalPosition.z);\n\n      // Simple footstep sound trigger (every 1.5 units walked)\n      if (Math.floor(distanceWalked.current / 1.5) > Math.floor((distanceWalked.current - movementDistance) / 1.5)) {\n        // Trigger footstep sound here\n        console.log('Footstep'); // Replace with actual audio\n      }\n    } else {\n      // No movement - sync camera without bob\n      camera.position.set(finalPosition.x, finalPosition.y + CAMERA_HEIGHT_OFFSET, finalPosition.z);\n    }\n    lastPosition.current.copy(finalPosition);\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(PointerLockControls, {\n      ref: controlsRef,\n      camera: camera,\n      domElement: document.body,\n      maxPolarAngle: Math.PI / 2 - 0.087 // +85 degrees\n      ,\n      minPolarAngle: -Math.PI / 2 + 0.087 // -85 degrees\n      ,\n      pointerSpeed: 0.5 // Smooth mouse movement\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 217,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RigidBody, {\n      ref: playerRef,\n      type: \"kinematicPosition\",\n      position: position,\n      colliders: \"ball\",\n      gravityScale: 0,\n      children: /*#__PURE__*/_jsxDEV(\"mesh\", {\n        visible: false,\n        children: [/*#__PURE__*/_jsxDEV(\"sphereGeometry\", {\n          args: [PLAYER_RADIUS]\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 235,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"meshBasicMaterial\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 236,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 234,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(PlayerController, \"0VlVSpImWddAIeUEGaXAbUDmLs4=\", false, function () {\n  return [useThree, useRapier, useKeyboard, useFrame];\n});\n_c = PlayerController;\nvar _c;\n$RefreshReg$(_c, \"PlayerController\");","map":{"version":3,"names":["useRef","useEffect","useFrame","useThree","RigidBody","useRapier","PointerLockControls","Vector3","useKeyboard","jsxDEV","_jsxDEV","Fragment","_Fragment","PlayerController","position","_s","playerRef","controlsRef","camera","world","keys","SPEED","FRICTION","PLAYER_HEIGHT","PLAYER_RADIUS","CAMERA_HEIGHT_OFFSET","velocity","distanceWalked","lastPosition","set","collisionProbe","testPosition","current","directions","x","y","z","dir","ray","castRay","undefined","effectiveRadius","points","maze","point","gridX","Math","floor","gridZ","length","headBob","phase","amplitude","_","delta","currentPos","translation","currentPosition","direction","forward","backward","left","right","normalize","yaw","rotation","worldDirection","cos","sin","intendedMove","multiplyScalar","frictionFactor","pow","add","finalMove","testPosX","clone","testPosZ","finalPosition","setNextKinematicTranslation","movementDistance","bobOffset","console","log","copy","children","ref","domElement","document","body","maxPolarAngle","PI","minPolarAngle","pointerSpeed","fileName","_jsxFileName","lineNumber","columnNumber","type","colliders","gravityScale","visible","args","_c","$RefreshReg$"],"sources":["C:/Users/subha/Downloads/ma/src/components/PlayerController.tsx"],"sourcesContent":["import { useRef, useEffect } from 'react';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\nimport { RigidBody, RapierRigidBody, useRapier } from '@react-three/rapier';\r\nimport { PointerLockControls } from '@react-three/drei';\r\nimport { Vector3, Euler } from 'three';\r\nimport { useKeyboard } from '../hooks/useKeyboard';\r\n\r\ninterface PlayerControllerProps {\r\n  position: [number, number, number];\r\n}\r\n\r\nexport const PlayerController: React.FC<PlayerControllerProps> = ({ position }) => {\r\n  const playerRef = useRef<RapierRigidBody>(null);\r\n  const controlsRef = useRef<any>(null);\r\n  const { camera } = useThree();\r\n  const { world } = useRapier();\r\n  const keys = useKeyboard();\r\n\r\n  // Professional movement constants - exactly as specified\r\n  const SPEED = 2.5; // units/second\r\n  const FRICTION = 8; // deceleration friction\r\n  const PLAYER_HEIGHT = 1.6; // meters\r\n  const PLAYER_RADIUS = 0.4; // meters\r\n  const CAMERA_HEIGHT_OFFSET = 1.5; // units\r\n\r\n  // Movement state\r\n  const velocity = useRef(new Vector3(0, 0, 0));\r\n  const distanceWalked = useRef(0);\r\n  const lastPosition = useRef(new Vector3(...position));\r\n\r\n  useEffect(() => {\r\n    // Set initial camera position\r\n    camera.position.set(position[0], position[1] + CAMERA_HEIGHT_OFFSET, position[2]);\r\n  }, [camera, position]);\r\n\r\n  // Professional collision probe using Rapier's ray casting\r\n  const collisionProbe = (testPosition: Vector3): boolean => {\r\n    if (!world || !playerRef.current) return false;\r\n\r\n    try {\r\n      // Use multiple ray casts to simulate capsule collision\r\n      const directions = [\r\n        { x: 1, y: 0, z: 0 },   // right\r\n        { x: -1, y: 0, z: 0 },  // left\r\n        { x: 0, y: 0, z: 1 },   // forward\r\n        { x: 0, y: 0, z: -1 },  // backward\r\n      ];\r\n\r\n      for (const dir of directions) {\r\n        const ray = world.castRay(\r\n          { x: testPosition.x, y: testPosition.y + PLAYER_HEIGHT / 2, z: testPosition.z },\r\n          dir,\r\n          PLAYER_RADIUS + 0.1,\r\n          true,\r\n          undefined,\r\n          undefined,\r\n          playerRef.current\r\n        );\r\n        \r\n        if (ray) return true;\r\n      }\r\n\r\n      return false;\r\n    } catch {\r\n      // Fallback to grid-based collision detection\r\n      const effectiveRadius = PLAYER_RADIUS * 0.8;\r\n      \r\n      // Check 4 corners of player bounding box\r\n      const points = [\r\n        { x: testPosition.x + effectiveRadius, z: testPosition.z + effectiveRadius },\r\n        { x: testPosition.x + effectiveRadius, z: testPosition.z - effectiveRadius },\r\n        { x: testPosition.x - effectiveRadius, z: testPosition.z + effectiveRadius },\r\n        { x: testPosition.x - effectiveRadius, z: testPosition.z - effectiveRadius },\r\n      ];\r\n\r\n      // Simple maze layout for fallback collision\r\n      const maze = [\r\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\r\n        [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],\r\n        [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],\r\n        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],\r\n        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\r\n        [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],\r\n        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\r\n        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],\r\n        [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],\r\n        [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1],\r\n        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],\r\n        [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 1],\r\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\r\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n      ];\r\n\r\n      for (const point of points) {\r\n        const gridX = Math.floor(point.x);\r\n        const gridZ = Math.floor(point.z);\r\n\r\n        // Check boundaries\r\n        if (gridZ < 0 || gridZ >= maze.length || gridX < 0 || gridX >= maze[0].length) {\r\n          return true;\r\n        }\r\n\r\n        // Check wall collision\r\n        if (maze[gridZ][gridX] === 1) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Head bob effect\r\n  const headBob = useRef({ phase: 0, amplitude: 0.02 });\r\n\r\n  useFrame((_, delta) => {\r\n    if (!playerRef.current) return;\r\n\r\n    // Get current position\r\n    const currentPos = playerRef.current.translation();\r\n    const currentPosition = new Vector3(currentPos.x, currentPos.y, currentPos.z);\r\n\r\n    // Calculate movement direction from input\r\n    const direction = new Vector3(0, 0, 0);\r\n    \r\n    if (keys.forward) direction.z -= 1;   // W / Up Arrow\r\n    if (keys.backward) direction.z += 1;  // S / Down Arrow  \r\n    if (keys.left) direction.x -= 1;      // A / Left Arrow\r\n    if (keys.right) direction.x += 1;     // D / Right Arrow\r\n\r\n    // Normalize direction for consistent speed\r\n    if (direction.length() > 0) {\r\n      direction.normalize();\r\n    }\r\n\r\n    // Apply camera yaw to world space movement\r\n    const yaw = camera.rotation.y;\r\n    const worldDirection = new Vector3(\r\n      direction.x * Math.cos(yaw) - direction.z * Math.sin(yaw),\r\n      0,\r\n      direction.z * Math.cos(yaw) + direction.x * Math.sin(yaw)\r\n    );\r\n\r\n    // Calculate intended movement\r\n    const intendedMove = worldDirection.multiplyScalar(SPEED * delta);\r\n\r\n    // Apply smooth deceleration friction\r\n    const frictionFactor = Math.pow(1 - FRICTION * delta, delta);\r\n    velocity.current.multiplyScalar(frictionFactor);\r\n\r\n    // Add new movement to velocity (smooth acceleration)\r\n    velocity.current.add(intendedMove);\r\n\r\n    // Precise anti-clipping algorithm\r\n    let finalMove = new Vector3(0, 0, 0);\r\n\r\n    // Check X movement separately\r\n    const testPosX = currentPosition.clone().add(new Vector3(velocity.current.x, 0, 0));\r\n    if (!collisionProbe(testPosX)) {\r\n      finalMove.x = velocity.current.x;\r\n    } else {\r\n      velocity.current.x = 0; // Stop X movement on collision\r\n    }\r\n\r\n    // Check Z movement separately  \r\n    const testPosZ = currentPosition.clone().add(new Vector3(0, 0, velocity.current.z));\r\n    if (!collisionProbe(testPosZ)) {\r\n      finalMove.z = velocity.current.z;\r\n    } else {\r\n      velocity.current.z = 0; // Stop Z movement on collision\r\n    }\r\n\r\n    // Apply final movement to rigid body\r\n    const finalPosition = currentPosition.add(finalMove);\r\n    playerRef.current.setNextKinematicTranslation({\r\n      x: finalPosition.x,\r\n      y: finalPosition.y,\r\n      z: finalPosition.z,\r\n    });\r\n\r\n    // Track distance walked for footsteps\r\n    const movementDistance = finalMove.length();\r\n    distanceWalked.current += movementDistance;\r\n\r\n    // Head bob effect when moving\r\n    if (movementDistance > 0.001) {\r\n      headBob.current.phase += movementDistance * 10;\r\n      const bobOffset = Math.sin(headBob.current.phase) * headBob.current.amplitude;\r\n      \r\n      // Sync camera position with head bob\r\n      camera.position.set(\r\n        finalPosition.x,\r\n        finalPosition.y + CAMERA_HEIGHT_OFFSET + bobOffset,\r\n        finalPosition.z\r\n      );\r\n\r\n      // Simple footstep sound trigger (every 1.5 units walked)\r\n      if (Math.floor(distanceWalked.current / 1.5) > Math.floor((distanceWalked.current - movementDistance) / 1.5)) {\r\n        // Trigger footstep sound here\r\n        console.log('Footstep'); // Replace with actual audio\r\n      }\r\n    } else {\r\n      // No movement - sync camera without bob\r\n      camera.position.set(\r\n        finalPosition.x,\r\n        finalPosition.y + CAMERA_HEIGHT_OFFSET,\r\n        finalPosition.z\r\n      );\r\n    }\r\n\r\n    lastPosition.current.copy(finalPosition);\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <PointerLockControls\r\n        ref={controlsRef}\r\n        camera={camera}\r\n        domElement={document.body}\r\n        maxPolarAngle={Math.PI / 2 - 0.087} // +85 degrees\r\n        minPolarAngle={-Math.PI / 2 + 0.087} // -85 degrees\r\n        pointerSpeed={0.5} // Smooth mouse movement\r\n      />\r\n      \r\n      <RigidBody\r\n        ref={playerRef}\r\n        type=\"kinematicPosition\"\r\n        position={position}\r\n        colliders=\"ball\"\r\n        gravityScale={0}\r\n      >\r\n        {/* Sphere collider for player (simpler than capsule) */}\r\n        <mesh visible={false}>\r\n          <sphereGeometry args={[PLAYER_RADIUS]} />\r\n          <meshBasicMaterial />\r\n        </mesh>\r\n      </RigidBody>\r\n    </>\r\n  );\r\n};"],"mappings":"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E,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC7C,CAAC,CAAC,EAAE,CAAC,EAAE,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}